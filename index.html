<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Path Tracing with Three.js</title>
  <style>
    body { margin: 0; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.166.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.166.0/examples/jsm/",
        "tweakpane": "https://cdn.jsdelivr.net/npm/tweakpane@4.0.3/dist/tweakpane.min.js"
      }
    }
  </script>
  
  <script type="module">

    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

    import { Pane } from 'tweakpane';
    import PathTracingShader from './shaders/PathTracingShader.js'
    import AccumulationPass from './AccumulationPass.js'
    import Stats from 'three/addons/libs/stats.module.js';
    
    function loadShader(path) {
      return fetch(path).then(response => response.text());
    }

    async function init() {

        const vertexShaderText = await loadShader('./shaders/vertex.vert');
        const fragmentShaderText = await loadShader('./shaders/fragment.frag');
        
        // Initialize the scene
        const scene = new THREE.Scene();
        // const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
        const camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 1000 );
        let cameraPosition = camera.position.set(0, 0, -1);
        let cameraDirection = new THREE.Vector3(0, 0, -1);
        let cameraRight = new THREE.Vector3(1, 0, 0);
        let cameraUp = new THREE.Vector3(0, 1, 0);

        // Initialize the renderer
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        const stats = new Stats();
        document.body.appendChild( stats.dom );

        const controls = new OrbitControls( camera, renderer.domElement );
        controls.addEventListener('change', () => accPass.iteration = 0);
        controls.update();


        // Load the GLTF model
        const loader = new GLTFLoader();
        const gltf = await loader.loadAsync('./model.glb');

        let meshes = [];
        gltf.scene.traverse((child) => {
            if (child.isMesh) {
                meshes.push(child);
            }
        });

        const triangles = [];
        // meshes.forEach(mesh => {
            const geometry = new THREE.BoxGeometry().scale(1, 1, 1).translate(0,0,-5);
            const material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
            // const geometry = mesh.geometry.translate(0,0,-5);//new THREE.PlaneGeometry( 1, 1 ).translate(0,0,-5);
            // const material = mesh.material;//new THREE.MeshBasicMaterial( { color: 0xff0000 } );
            const positionAttribute = geometry.attributes.position;
            const normalAttribute = geometry.attributes.normal;
            const count = !geometry.index ? positionAttribute.count / 3 : geometry.index?.count;
            const index = !geometry.index ? positionAttribute : geometry.index;

            for (let i = 0; i < count; i += 3) {
                const a = index.getX(i);
                const b = index.getX(i + 1);
                const c = index.getX(i + 2);

                const posA = new THREE.Vector3().fromBufferAttribute(positionAttribute, a);
                const posB = new THREE.Vector3().fromBufferAttribute(positionAttribute, b);
                const posC = new THREE.Vector3().fromBufferAttribute(positionAttribute, c);

                const normalA = new THREE.Vector3().fromBufferAttribute(normalAttribute, a);
                const normalB = new THREE.Vector3().fromBufferAttribute(normalAttribute, b);
                const normalC = new THREE.Vector3().fromBufferAttribute(normalAttribute, c);

                triangles.push({
                    posA,
                    posB,
                    posC,
                    normalA,
                    normalB,
                    normalC,
                    material: {
                        color: material.color,
                        emissionColor: new THREE.Color(1,1,1),
                        emissionStrength: 1
                    }
                });
            }
        // });

        // const triangles = [
        //     {
        //         posA: new THREE.Vector3(-1, -1, -5),
        //         posB: new THREE.Vector3(1, -1, -5),
        //         posC: new THREE.Vector3(0, 1, -5),
        //         normalA: new THREE.Vector3(0, 0, 1),
        //         normalB: new THREE.Vector3(0, 0, 1),
        //         normalC: new THREE.Vector3(0, 0, 1),
        //         material: {
        //             color: new THREE.Vector3(1, 0, 0),
        //             emissionColor: new THREE.Vector3(0, 0, 0),
        //             emissionStrength: 0.0
        //         }
        //     },
        // ];

        // Define the spheres and their materials
        const spheres = [
            { position: new THREE.Vector3(0, 2, -5), radius: 1.0, material: { color: new THREE.Color(1, 1, 1), emissionColor: new THREE.Color(1, 1, 1), emissionStrength: 2 } },
            { position: new THREE.Vector3(2, 0, -5), radius: 1.0, material: { color: new THREE.Color(0, 1, 0), emissionColor: new THREE.Color(1, 1, 1), emissionStrength: 0.0 } },
            { position: new THREE.Vector3(-2, 0, -5), radius: 1.0, material: { color: new THREE.Color(0, 0, 1), emissionColor: new THREE.Color(1, 1, 1), emissionStrength: 0.0 } },
            { position: new THREE.Vector3(0, -26, -5), radius: 25.0, material: { color: new THREE.Color(0.9, 0.9, 0.9), emissionColor: new THREE.Color(1, 1, 1), emissionStrength: 0.0 } },
        ];

        const composer = new EffectComposer( renderer );
        const pathTracingPass = new ShaderPass( PathTracingShader );
        pathTracingPass.uniforms.resolution.value = new THREE.Vector2(window.innerWidth, window.innerHeight),
        pathTracingPass.uniforms.cameraPos.value = controls.object.position;
        pathTracingPass.uniforms.cameraDir.value = cameraDirection;
        pathTracingPass.uniforms.cameraRight.value = cameraRight;
        pathTracingPass.uniforms.cameraUp.value = cameraUp;

        pathTracingPass.uniforms.frame.value = 0;
        pathTracingPass.uniforms.maxBounceCount.value = 1;
        pathTracingPass.uniforms.numRaysPerPixel.value = 1;

        pathTracingPass.uniforms.spheres.value = spheres;
        pathTracingPass.material.defines.MAX_SPHERE_COUNT = spheres.length;

        pathTracingPass.uniforms.triangles.value = triangles;
        pathTracingPass.material.defines.MAX_TRIANGLE_COUNT = triangles.length;

		pathTracingPass.name = 'pathTracingPass';
		composer.addPass( pathTracingPass );

        const accPass = new AccumulationPass( scene, window.innerWidth, window.innerHeight );
		composer.addPass( accPass );

        const pane = new Pane({ title: 'Parameters', expanded: false });
        pane.addBinding(pathTracingPass.uniforms.maxBounceCount, 'value', { label: 'bounce', min: 1, max: 5, step: 1 });
        pane.addBinding(pathTracingPass.uniforms.numRaysPerPixel, 'value', { label: 'rays per pixel', min: 1, max: 20, step: 1 });
        pane.addBinding(pathTracingPass.uniforms.spheres.value[0], 'position');
        pane.addBinding(pathTracingPass.uniforms.spheres.value[0].material, 'emissionStrength', { min: 0, max: 5, });
        pane.addBinding(pathTracingPass.uniforms.spheres.value[0].material, 'emissionColor', { color: {type: 'float'} });
        pane.addBinding(pathTracingPass.uniforms.spheres.value[1].material, 'color', { color: {type: 'float'} });
        pane.addBinding(pathTracingPass.uniforms.spheres.value[2].material, 'color', { color: {type: 'float'} });
        pane.addBinding(pathTracingPass.uniforms.spheres.value[3].material, 'color', { color: {type: 'float'} });
        pane.on('change', ev => accPass.iteration = 0 );
        
        let tempMatrix = null
        // Render the scene
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            
            cameraPosition = controls.object.position;
            tempMatrix = controls.object.matrixWorld.elements
            cameraUp.set( tempMatrix[ 4 ], tempMatrix[ 5 ], tempMatrix[ 6 ] ).normalize();
            cameraRight.set( tempMatrix[ 0 ], tempMatrix[ 1 ], tempMatrix[ 2 ] ).normalize();
            cameraDirection.set( tempMatrix[ 8 ], tempMatrix[ 9 ], tempMatrix[ 10 ] ).normalize();
            
            pathTracingPass.uniforms.frame.value++;
            composer.render();
            stats.update();
        }
        
        animate();
        
        // Handle window resize
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            pathTracingPass.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
        });
    }
    init();

  </script>
</body>
</html>
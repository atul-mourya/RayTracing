<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Path Tracing with Three.js</title>
  <style>
    body { margin: 0; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.166.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.166.0/examples/jsm/",
        "tweakpane": "https://cdn.jsdelivr.net/npm/tweakpane@4.0.3/dist/tweakpane.min.js"
      }
    }
  </script>
  
  <script type="module">

    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

    import { Pane } from 'tweakpane';
    import AccumulationPass from './AccumulationPass.js'
    import Stats from 'three/addons/libs/stats.module.js';
    
    function loadShader(path) {
      return fetch(path).then(response => response.text());
    }

    async function init() {

        const vertexShaderText = await loadShader('./shaders/vertex.vert');
        const fragmentShaderText = await loadShader('./shaders/fragment.frag');
        
        // Initialize the scene
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
        // const camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );
        camera.position.set(0, 0, 1);

        // Initialize the renderer
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        const stats = new Stats();
        document.body.appendChild( stats.dom );

        const controls = new OrbitControls( camera, renderer.domElement );
        controls.update();


        // Define the spheres and their materials
        const spheres = [
            { position: new THREE.Vector3(0, 0, -5), radius: 1.0, color: new THREE.Color(1, 1, 1), emissionColor: new THREE.Color(1, 1, 1), emissionStrength: 1 },
            { position: new THREE.Vector3(2, 0, -5), radius: 1.0, color: new THREE.Color(0, 1, 0), emissionColor: new THREE.Color(1, 1, 1), emissionStrength: 0.0 },
            { position: new THREE.Vector3(-2, 0, -5), radius: 1.0, color: new THREE.Color(0, 0, 1), emissionColor: new THREE.Color(1, 1, 1), emissionStrength: 0.0 },
            { position: new THREE.Vector3(0, -26, -5), radius: 25.0, color: new THREE.Color(0.9, 0.9, 0.9), emissionColor: new THREE.Color(1, 1, 1), emissionStrength: 0.0 },
        ];

        // Create a plane geometry and material with shaders
        const geometry = new THREE.PlaneGeometry(2, 2);
        const material = new THREE.ShaderMaterial({
            vertexShader: vertexShaderText,
            fragmentShader: fragmentShaderText,
            uniforms: {
                resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                cameraPos: { value: new THREE.Vector3(0, 0, 0) },
                cameraDir: { value: new THREE.Vector3(0, 0, -1) },
                cameraRight: { value: new THREE.Vector3(1, 0, 0) },
                cameraUp: { value: new THREE.Vector3(0, 1, 0) },
                numSpheres: { value: spheres.length },
                frame: { value: 0 },
                maxBounceCount: { value: 1 },
                numRaysPerPixel: { value: 1 },
                spheres: { value: spheres.map(sphere => ({
                        position: sphere.position,
                        radius: sphere.radius,
                        material: { 
                            color: sphere.color ,
                            emissionColor: sphere.emissionColor,
                            emissionStrength: sphere.emissionStrength,
                        }
                    })) 
                }
            }
        });

        const plane = new THREE.Mesh(geometry, material);
        scene.add(plane);

        const composer = new EffectComposer( renderer );
        const renPass = new RenderPass( scene, camera );
		renPass.name = 'renPass';
		composer.addPass( renPass );

        const accPass = new AccumulationPass( scene, window.innerWidth, window.innerHeight );
		accPass.name = 'accPass';
		composer.addPass( accPass );

        const pane = new Pane();
        pane.addBinding(material.uniforms.maxBounceCount, 'value', { label: 'bounce', min: 1, max: 5, step: 1 });
        pane.addBinding(material.uniforms.numRaysPerPixel, 'value', { label: 'rays per pixel', min: 1, max: 20, step: 1 });
        pane.addBinding(material.uniforms.spheres.value[0], 'position');
        pane.addBinding(material.uniforms.spheres.value[0].material, 'emissionStrength', { min: 0, max: 1, });
        pane.addBinding(material.uniforms.spheres.value[0].material, 'emissionColor', { color: {type: 'float'} });
        pane.addBinding(material.uniforms.spheres.value[1].material, 'color', { color: {type: 'float'} });
        pane.addBinding(material.uniforms.spheres.value[2].material, 'color', { color: {type: 'float'} });
        pane.addBinding(material.uniforms.spheres.value[3].material, 'color', { color: {type: 'float'} });

        pane.on('change', ev => {
            accPass.iteration = 0;
        })
        
        // Render the scene
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            // material.uniforms.spheres.value[0].position.y = Math.cos(material.uniforms.frame.value/10);
            material.uniforms.frame.value++;
            composer.render();
            stats.update();
        }
        
        animate();
        
        // Handle window resize
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            material.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
        });
    }
    init();

  </script>
</body>
</html>
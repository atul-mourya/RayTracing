<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Path Tracing with Three.js</title>
  <style>
    body { margin: 0; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.166.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.166.0/examples/jsm/",
        "tweakpane": "https://cdn.jsdelivr.net/npm/tweakpane@4.0.3/dist/tweakpane.min.js"
      }
    }
  </script>
  
  <script type="module">

    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

    import { Pane } from 'tweakpane';
    import PathTracingShader from './shaders/PathTracingShader.js'
    import AccumulationPass from './AccumulationPass.js'
    import Stats from 'three/addons/libs/stats.module.js';
    
    function loadShader(path) {
      return fetch(path).then(response => response.text());
    }

    async function init() {

        const vertexShaderText = await loadShader('./shaders/vertex.vert');
        const fragmentShaderText = await loadShader('./shaders/fragment.frag');
        
        // Initialize the scene
        const scene = new THREE.Scene();
        // const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
        const camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 1000 );
        let cameraPosition = camera.position.set(0, 0, -1);
        let cameraDirection = new THREE.Vector3(0, 0, -1);
        let cameraRight = new THREE.Vector3(1, 0, 0);
        let cameraUp = new THREE.Vector3(0, 1, 0);

        // Initialize the renderer
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        const stats = new Stats();
        document.body.appendChild( stats.dom );

        const controls = new OrbitControls( camera, renderer.domElement );
        controls.addEventListener('change', () => accPass.iteration = 0);
        controls.update();

        const triangles = [
            {
                posA: new THREE.Vector3(-1, -1, -5),
                posB: new THREE.Vector3(1, -1, -5),
                posC: new THREE.Vector3(0, 1, -5),
                normalA: new THREE.Vector3(0, 0, 1),
                normalB: new THREE.Vector3(0, 0, 1),
                normalC: new THREE.Vector3(0, 0, 1),
                material: {
                    color: new THREE.Vector3(1, 0, 0),
                    emissionColor: new THREE.Vector3(0, 0, 0),
                    emissionStrength: 0.0
                }
            },
        ];

        // Define the spheres and their materials
        const spheres = [
            { position: new THREE.Vector3(0, 2, -5), radius: 1.0, material: { color: new THREE.Color(1, 1, 1), emissionColor: new THREE.Color(1, 1, 1), emissionStrength: 2 } },
            { position: new THREE.Vector3(2, 0, -5), radius: 1.0, material: { color: new THREE.Color(0, 1, 0), emissionColor: new THREE.Color(1, 1, 1), emissionStrength: 0.0 } },
            { position: new THREE.Vector3(-2, 0, -5), radius: 1.0, material: { color: new THREE.Color(0, 0, 1), emissionColor: new THREE.Color(1, 1, 1), emissionStrength: 0.0 } },
            { position: new THREE.Vector3(0, -26, -5), radius: 25.0, material: { color: new THREE.Color(0.9, 0.9, 0.9), emissionColor: new THREE.Color(1, 1, 1), emissionStrength: 0.0 } },
        ];

        const composer = new EffectComposer( renderer );
        const pathTracingPass = new ShaderPass( PathTracingShader );
        pathTracingPass.uniforms.resolution.value = new THREE.Vector2(window.innerWidth, window.innerHeight),
        pathTracingPass.uniforms.cameraPos.value = controls.object.position;
        pathTracingPass.uniforms.cameraDir.value = cameraDirection;
        pathTracingPass.uniforms.cameraRight.value = cameraRight;
        pathTracingPass.uniforms.cameraUp.value = cameraUp;

        pathTracingPass.uniforms.frame.value = 0;
        pathTracingPass.uniforms.maxBounceCount.value = 1;
        pathTracingPass.uniforms.numRaysPerPixel.value = 1;

        pathTracingPass.uniforms.numSpheres.value = spheres.length;
        pathTracingPass.uniforms.spheres.value = spheres;

        pathTracingPass.uniforms.triangles.value = triangles;
        pathTracingPass.uniforms.numTriangles.value = triangles.length;

		pathTracingPass.name = 'pathTracingPass';
		composer.addPass( pathTracingPass );

        const accPass = new AccumulationPass( scene, window.innerWidth, window.innerHeight );
		accPass.name = 'accPass';
		composer.addPass( accPass );

        const pane = new Pane();
        pane.addBinding(pathTracingPass.uniforms.maxBounceCount, 'value', { label: 'bounce', min: 1, max: 5, step: 1 });
        pane.addBinding(pathTracingPass.uniforms.numRaysPerPixel, 'value', { label: 'rays per pixel', min: 1, max: 20, step: 1 });
        pane.addBinding(pathTracingPass.uniforms.spheres.value[0], 'position');
        pane.addBinding(pathTracingPass.uniforms.spheres.value[0].material, 'emissionStrength', { min: 0, max: 5, });
        pane.addBinding(pathTracingPass.uniforms.spheres.value[0].material, 'emissionColor', { color: {type: 'float'} });
        pane.addBinding(pathTracingPass.uniforms.spheres.value[1].material, 'color', { color: {type: 'float'} });
        pane.addBinding(pathTracingPass.uniforms.spheres.value[2].material, 'color', { color: {type: 'float'} });
        pane.addBinding(pathTracingPass.uniforms.spheres.value[3].material, 'color', { color: {type: 'float'} });
        pane.on('change', ev => accPass.iteration = 0 );
        
        let tempMatrix = null
        // Render the scene
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            
            cameraPosition = controls.object.position;
            tempMatrix = controls.object.matrixWorld.elements
            cameraUp.set( tempMatrix[ 4 ], tempMatrix[ 5 ], tempMatrix[ 6 ] ).normalize();
            cameraRight.set( tempMatrix[ 0 ], tempMatrix[ 1 ], tempMatrix[ 2 ] ).normalize();
            cameraDirection.set( tempMatrix[ 8 ], tempMatrix[ 9 ], tempMatrix[ 10 ] ).normalize();
            
            pathTracingPass.uniforms.frame.value++;
            composer.render();
            stats.update();
        }
        
        animate();
        
        // Handle window resize
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            pathTracingPass.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
        });
    }
    init();

  </script>
</body>
</html>